# MSTest Enhancer

在 MSTestEnhancer 的帮助下，单元测试将更加容易编写、理解和维护。因为它让单元测试方法和被测类本身之间的关系更加紧密。

## 如何开始

1. 在单元测试项目中安装 NuGet 包：[MSTestEnhancer](https://www.nuget.org/packages/MSTestEnhancer/)。
1. 现在就可以开始编写下文那种风格的单元测试代码了。

## 推荐的单元测试编写方式

```csharp
[TestClass]
public class 被测类名Test
{
    [ContractTestCase]
    public void 被测方法名()
    {
        "契约 1（当 Xxx 时，应该发生 Yyy）".Test(() =>
        {
            // 测试用例代码
        });
        
        "契约 2（但当 Zzz 时，应该发生 Www）".Test(() =>
        {
            // 测试用例代码
        });
    }
}
```

注意到单元测试类的名称和原本的类名称是一一对应的，方法名和原本的方法名是一模一样的；于是，我们不再需要为任何一个单元测试思考命名问题。

![单元测试结果页](/docs/images/2018-02-12-08-54-31.png)

## 参数化的单元测试

有些契约需要更多的值组合来验证正确性，那么可以在契约测试用例的后面添加参数。

```csharp
"质数".Test((int num) =>
{
    // 测试用例代码
}).WithArguments(2, 3, 5, 7, 11);

"{0} 不是质数".Test((int num) =>
{
    // 测试用例代码
}).WithArguments(1, 4);
```

也可以添加多个参数（最多支持 8 个）：

```csharp
"契约 1，参数中可以带 {0} 和 {1}。".Test((int a, int b) =>
{
    // 现在，a 会等于 2，b 会等于 3。
}).WithArguments(2, 3);

"契约 2".Test((int a, int b) =>
{
    // 现在有两组代码，一组 a=2, b=3；另一组 a=10, b=20。
    // 当然也可以传入元组数组。
}).WithArguments((2, 3), (10, 20));
```

在显示单元测试结果时，如果契约字符串中含有格式化占位符 `{0}`、`{1}` 等，会被自动替换为参数的值。

## 异步的单元测试

`Test` 方法中传入的每个 `Action` 都支持 `async` 关键字，并会在执行测试用例时等待异步操作结束。

## 额外的黑科技

MSTest v2 支持嵌套类型的单元测试。也就是说，我们可以利用这一点做出近乎无限层级的单元测试树出来。
